Next hurdle: Make a good movement system!

Lessons from Tim's playtest session:
Movement system and level design must mesh. Maybe more important than either alone.
Make it visually intuitive.
Forcefield is visually misleading: Tim thought tapping forcefield made it more powerful.
Force direction not visually clear.

What makes a good movement system?
1. Not frustrating
	Not too hard to master; not too much learning curve
	Things that look easy, are easy; no "gotchas"
	Predictable
2. *Enables* the player to do "extra" things: Not always? But can be
3. Not exploitable; not hard to design levels around
	Things that look hard / are designed to be, are hard
4. Intangibly satisfying, like Warning Forever or multidash in HLD.
The current movement system breaks ALL of these rules!

Case studies:

Cave Story: Base movement system satisfies 1, 2, 3.
Booster v1 is not frustrating, enabling, somewhat satisfying
Booster v2 has a steeper learning curve, but is much more satisfying, rewards the optional additional effort
Principle: More challenging movement systems are OK if they're optional for advanced players and reward the extra effort.

Rain world: Satisfies 3 only, but fits very well thematically. Can be satisfying at times, but not very good IMO.
Exception: Combat is a major strength. Throwing spears is thrilling in a way that makes cave story's button-mashing seem meaningless.

Hyper Light Drifter: Timing is everything, but this isn't taught to the player. Can be frustrating.
Enabling
Not exploitable
Satisfying

Celeste: Not frustrating: Gives you powerful, intuitive tools, but asks you to do hard things quickly with them.
Not frustrating
*very* enabling
Exploitable, to a limited extent
*very* satisfying

Within A Deep Forest: Novel movement system requires a lot of getting used to, but can pay off.
Takes time to master; can be frustrating; things that look easy are hard.
Enables the player: Not really? Strictly weaker than a normal movement system.
Not exploitable
Not really satisfying

Portal: Intertia-based puzzle movement system. Just gets around the problem by being puzzle-focused without much hard platforming at all.

I think I'm too afraid to surprise the player. Learning a new movement system isn't all bad; in fact,
buying a new game and discovering you already know how to play it would be kinda frustrating. Just as long
as it has an acceptable learning curve.

Goals:
- Platformable:
	- Release jump button early to limit jump height
	- Change direction in midair
	- Crisp movement
	- Walljumps, double jumps, etc.
But also:
	- Can be flung long distances by forcefields

Major options:
- Fully inertia-based in X and Y axes
- Fully inertia-based, but allow player to stop in midair by pressing down
- Fully inertia-based in Y axis, give player full control in X axis.
- Fully inertia-based until player takes control again by pressing a movement button, and then add X friction.
- Like Gris or Portal, make all platforming challenges optional, and only solving puzzles is necessary to progress. Challenge by choice.

Can also play with:
- Speed: Slowing things down makes a challenging movement system much more palatable.
- Max fall speed (might mess with fun stuff like trampolines)

Probably want to (in general) have single-direction forcefields, since they're more intuitive to
reason about. Probably want a system which is fully inertia-based in Y axis, gives player full control
in X axis (basically, behaves as closely to a traditional platformer as possible) in the absence of
a horizontal force. Not sure how horizontal forces should be handled, but they can be used minimally/
as an optional extra challenge.

At least early on, forcefields should be clearly delineated with arrow markers. Could even have
them light up when activated! Could do some neat stuff with black and yellow hazard stripes.

Loose ends:
- Entities are loaded out-of-order.
    - Need to re-integrate player loading into gameleveldata::readEntities
    - Newly added entities currently go on top/bottom: Could solve this by having the "parent" entity contain and pass a list iterator pointing to itself to collider::addEntity, or could keep collider sorted by sizeFactor (?)
    - HUD is not always printing on top! Add a separate printHUD function?
- Layers still getting deleted multiple times under some circumstances?
- Gun selection indicator
- Revise physicalEntity movement code to be xyxyxy instead of xxxyyy

Features:
? Editor misc:
    - Allow changing background color
    - Display, allow changing palette selection (don't ignore number keys) in tab screen
    - Add a layer indicator which shows all of the layers and which one is selected
    - Fix the default palette
    - Displaying and resizing variable-size entities (e.g. water, particle spawner) in editor.
    - Need to be able to correspond entities in the file to entities in the editor more easily.
- Need maxAmmoPickup
- Config file: Resolution, scaling
? Generic physicalEntity parameters (density/volume/mass)
- Improved code interface
    - Intercepted codes
    - Colored based on code value
    - Broadcast animation
- Puzzle elements:
    - Switches
    - Triggers
    - Color changing/other effect layers
    - AND/OR/Timer relays
    - Doors
    - Disappearing platforms
- Combat elements:
    - Gun/turret enemies
    - Fast-moving enemies
- Story elements:
    - persistent plot variables.
    - Separate global- and outfit- scope? (e.g. beating boss = global scope, key = outfit scope)
    - An inventory. Can probably be purely cosmetic.
    - Doors that can be locked or unlocked depending on plot variables from either scope.
        - More generally, want entity state to depend on plot variables. 
    - Potential implementation: Global- and outfit- scope implemented as a set of ints, similar to the system for keeping track of which pickups have been collected already. They are stored in the save but           loaded into the collider and can be accessed the same way as broadcast codes.
    - NPCS and bosses which can modify plot variables.
    - Dialog
    ? Inventory
- Sound effects
- Music: see http://dig.ccmixter.org for free music, or contact noise, or try to make your own!
- Menus
- Controller support
? Wind/current object
? leaf physicalParticles that fly eratically
? Digital corruption visual effect; layer turns into random characters suddenly, gradually resolves back into
    original.
? Lightning bolt, fire (spreads via embers), huge fireballs
? Snakes (like in snake game) that move around and you can jump on them (platforming puzzle element)
- transition visual effect
? Wave and rocket guns

Ideas:
    - Cyberpunk theme: Parallel digital and physical realms, distinct visual style, distinct puzzle types
    - Level where you find breath upgrades above water and ops below water - back and forth between those two
    - Level that is completely dark, must use bouncing particle explosion effect to navigate
    - WRT puzzles: Should give player feedback on plausible but wrong attempts, keep them entertained
    - You have a computer companion which is what allows you to broadcast codes. It has a test level which acts as
        the tutorial, also has randomly-generated puzzles with small bonuses.
    - Command line graphical effect when logging into a terminal.
    - Setting similar to New York 2140
        - Flooded coastal city decades from now after a climate apocalypse
        - Lowlands mostly abandoned, but buildings are hardened against the elements and continue to function
            - Robotic maintenance crews
            - Small-scale fission reactors
            - Internal networks functioning, external ones not so much
        - Circumstances of abandonment suspicious; possibly the gov't brought down the network and forced
            the city to be abandoned because an AGI was developed in one of the buildings, deemed too dangerous
            to interact with
    - Tutorial level: Older bro got you your neural interface hacking device, rewrote an abandoned building's
        network to teach you how to use it. Later he disappears, and you need to travel deeper into the abandoned
        city to find him...
    - Level where you're really bouncy, elasticity = 1.05 or something like that, but there are pools of water around and you need to use them to stop...

inspiration/vague visual ideas:
    - Giant drum machine like washing machine
    - Submechanophobia
    - Trippy AI face that speaks to you/watches you in the virtual world
        - AI doesn't want you poking around, if you go to far into his world he threatens you then starts killing you
            IRL and you have to get out of the level before he kills you entirely. Makes more sense if you don't usually
            have a health bar in the virtual world. Making virtual world one-hit-kill makes sense for small, puzzle-oriented levels.
    

Housekeeping items (may never get to all of these):
- Rewrite player::apply to be less confusing; maybe stop using bitsets, just use uint8_ts
- Docs, including "lessons learned"
- Replace x, y with Vector2 everywhere
- Create configure() functions rather than having 10-argument constructors/standardize constructor argument order
- Cap line lengths
- change everything from camelCase to PascalCase - use Perl to identify variable names using declarations? what about scoping?
- rename sizeFactor to Scale
- make layer use char[][] for mild performance benefits
- Convert rain to a generic random particle spawner that can spawn particles within a given box area
- Come up with better names for everything
- Several items which should be done together:
    - Rewrite save system as JSON
    - Rewrite player to not use so many fixed-size arrays
    - Create gun and op objects in player, instead of having a bunch of arrays
    - Guns and ops stored in player; pickups just unlock them.
        - Op data can be passed to player in readEntities() in game_main.cpp

Bugs:
- player disappears when standing on tile right below top of level
- touch pickups sometimes collected (?) randomly
- Markers appearing in wrong place in level editor
- "Not a valid choice!" error appears when using op screen
- particles becoming zero-G
- Some of the files in "dark" getting loaded as wrong width
- Water appears weird when player is moving very slowly in the vertical direction
- If there are two water objects with one above the other, they tend to interfere.
- Particles don't appear right next to walls
